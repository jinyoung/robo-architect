<script setup>
import { computed, ref, onMounted, inject } from 'vue'
import { useNavigatorStore } from '../stores/navigator'
import { useCanvasStore } from '../stores/canvas'
import { useTerminologyStore } from '../stores/terminology'

const props = defineProps({
  node: {
    type: Object,
    required: true
  },
  tree: {
    type: Object,
    default: null
  },
  depth: {
    type: Number,
    default: 0
  }
})

const navigatorStore = useNavigatorStore()
const canvasStore = useCanvasStore()
const terminologyStore = useTerminologyStore()

// Inject edit function from App.vue
const editUserStory = inject('editUserStory', null)

const isDragging = ref(false)
const showEntrance = ref(false)

// Entrance animation for new items
onMounted(() => {
  if (navigatorStore.isNewlyAdded(props.node.id)) {
    showEntrance.value = true
    setTimeout(() => {
      showEntrance.value = false
    }, 2000)
  }
})

// Check if node is newly added
const isNewlyAdded = computed(() => navigatorStore.isNewlyAdded(props.node.id))

// Get node type icon based on developer mode
const nodeIcon = computed(() => {
  if (terminologyStore.developerMode) {
    const devIcons = {
      UserStory: 'US',
      BoundedContext: 'MS',
      Aggregate: 'DB',
      Command: 'API',
      Event: 'E',
      Policy: 'SVC'
    }
    return devIcons[props.node.type] || '?'
  }
  const icons = {
    UserStory: 'US',
    BoundedContext: 'BC',
    Aggregate: 'A',
    Command: 'C',
    Event: 'E',
    Policy: 'P'
  }
  return icons[props.node.type] || '?'
})

// Format user story display name
const displayName = computed(() => {
  if (props.node.type === 'UserStory') {
    const role = props.node.role || 'user'
    const action = props.node.action || ''
    return `${role}: ${action.substring(0, 30)}${action.length > 30 ? '...' : ''}`
  }
  return props.node.name
})

// Get children based on node type
const children = computed(() => {
  const type = props.node.type
  
  if (type === 'BoundedContext') {
    if (!props.tree) return []
    
    // User Stories under this BC come first
    const userStories = (props.tree.userStories || []).map(us => ({
      ...us,
      type: 'UserStory',
      name: us.name || `${us.role}: ${us.action?.substring(0, 25)}...`
    }))
    
    const aggregates = (props.tree.aggregates || []).map(a => ({
      ...a,
      type: 'Aggregate'
    }))
    const policies = (props.tree.policies || []).map(p => ({
      ...p,
      type: 'Policy'
    }))
    return [...userStories, ...aggregates, ...policies]
  }
  
  if (type === 'Aggregate') {
    const commands = (props.node.commands || []).map(c => ({
      ...c,
      type: 'Command'
    }))
    const events = (props.node.events || []).map(e => ({
      ...e,
      type: 'Event'
    }))
    return [...commands, ...events]
  }
  
  if (type === 'Command') {
    return (props.node.events || []).map(e => ({
      ...e,
      type: 'Event'
    }))
  }
  
  // UserStory has no children
  if (type === 'UserStory') {
    return []
  }
  
  return []
})

const hasChildren = computed(() => children.value.length > 0)

const isExpanded = computed(() => navigatorStore.isExpanded(props.node.id))

const isOnCanvas = computed(() => canvasStore.isOnCanvas(props.node.id))

function toggleExpand() {
  navigatorStore.toggleExpanded(props.node.id)
}

// Double click handler - for UserStory opens edit modal, for others adds to canvas
async function handleDoubleClick() {
  if (props.node.type === 'UserStory') {
    // Open edit modal for user stories
    if (editUserStory) {
      editUserStory(props.node)
    }
  } else {
    // Add other node types to canvas
    await addToCanvas()
  }
}

// Drag handlers
function handleDragStart(event) {
  isDragging.value = true
  event.dataTransfer.setData('application/json', JSON.stringify({
    nodeId: props.node.id,
    nodeType: props.node.type,
    nodeData: props.node
  }))
  event.dataTransfer.effectAllowed = 'copy'
}

function handleDragEnd() {
  isDragging.value = false
}

// Add node to canvas with expanded data (including BC container)
async function addToCanvas() {
  if (isOnCanvas.value) return
  
  try {
    // Use the new API that includes BC context
    const response = await fetch(`/api/graph/expand-with-bc/${props.node.id}`)
    const data = await response.json()
    
    // Track which nodes are being added
    const newNodeIds = data.nodes.map(n => n.id)
    
    canvasStore.addNodesWithLayout(data.nodes, data.relationships, data.bcContext)
    
    // Find cross-BC relations (Event → TRIGGERS → Policy)
    await canvasStore.findCrossBCRelations(newNodeIds)
    
    // Also find any other relations
    await canvasStore.findAndAddRelations()
  } catch (error) {
    console.error('Failed to expand node:', error)
    // Fallback: add just this node
    canvasStore.addNode(props.node)
  }
}
</script>

<template>
  <div class="tree-node" :class="{ 'is-new': isNewlyAdded }">
    <div 
      class="tree-node__header"
      :class="{ 'is-dragging': isDragging, 'is-on-canvas': isOnCanvas, 'is-newly-added': isNewlyAdded }"
      :style="{ paddingLeft: `${depth * 12}px` }"
      :draggable="true"
      @click="toggleExpand"
      @dblclick="handleDoubleClick"
      @dragstart="handleDragStart"
      @dragend="handleDragEnd"
    >
      <!-- Toggle Arrow -->
      <span 
        class="tree-node__toggle"
        :class="{ 'is-expanded': isExpanded, 'is-hidden': !hasChildren }"
      >
        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <polyline points="9 18 15 12 9 6"></polyline>
        </svg>
      </span>
      
      <!-- Type Icon -->
      <span 
        class="tree-node__icon"
        :class="`tree-node__icon--${node.type.toLowerCase()}`"
      >
        {{ nodeIcon }}
      </span>
      
      <!-- Label -->
      <span 
        class="tree-node__label" 
        :title="node.type === 'UserStory' 
          ? `As a ${node.role || 'user'}, I want to ${node.action || '...'}${node.benefit ? ', so that ' + node.benefit : ''}\n\n(Double-click to edit)`
          : node.description"
      >
        {{ displayName }}
      </span>
      
      <!-- Policy trigger info -->
      <span v-if="node.type === 'Policy' && node.triggerEventId" class="tree-node__trigger">
        ← {{ node.triggerEventId.replace(/^EVT-/, '').replace(/-/g, ' ').toLowerCase() }}
      </span>
      
      <!-- Badge for children count -->
      <span v-if="hasChildren && !isExpanded" class="tree-node__badge">
        {{ children.length }}
      </span>
      
      <!-- Edit button for user stories -->
      <button 
        v-if="node.type === 'UserStory'" 
        class="tree-node__edit-btn"
        title="Edit User Story (Double-click)"
        @click.stop="handleDoubleClick"
      >
        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
          <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
        </svg>
      </button>
      
      <!-- On canvas indicator -->
      <span v-if="isOnCanvas" class="tree-node__on-canvas">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <polyline points="20 6 9 17 4 12"></polyline>
        </svg>
      </span>
    </div>
    
    <!-- Children -->
    <div v-if="isExpanded && hasChildren" class="tree-node__children">
      <TreeNode
        v-for="child in children"
        :key="child.id"
        :node="child"
        :tree="null"
        :depth="depth + 1"
      />
    </div>
  </div>
</template>

<style scoped>
.tree-node.is-new {
  animation: slideInNode 0.4s ease-out;
}

@keyframes slideInNode {
  from {
    opacity: 0;
    transform: translateX(-20px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
}

.tree-node__header.is-on-canvas {
  background: rgba(34, 139, 230, 0.1);
}

.tree-node__header.is-on-canvas:hover {
  background: rgba(34, 139, 230, 0.15);
}

.tree-node__header.is-newly-added {
  animation: pulseGlow 1.5s ease-in-out 2;
  position: relative;
}

.tree-node__header.is-newly-added::before {
  content: '';
  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  width: 3px;
  background: linear-gradient(180deg, var(--color-accent), var(--color-event));
  border-radius: 2px;
  animation: slideDown 0.5s ease-out;
}

@keyframes pulseGlow {
  0%, 100% {
    background: transparent;
  }
  50% {
    background: rgba(34, 139, 230, 0.15);
  }
}

@keyframes slideDown {
  from {
    transform: scaleY(0);
    opacity: 0;
  }
  to {
    transform: scaleY(1);
    opacity: 1;
  }
}

.tree-node__on-canvas {
  color: var(--color-accent);
  display: flex;
  align-items: center;
}

.tree-node__trigger {
  font-size: 0.65rem;
  color: var(--color-text-light);
  opacity: 0.7;
  font-style: italic;
  margin-left: 4px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 120px;
}

/* Edit button for user stories */
.tree-node__edit-btn {
  width: 22px;
  height: 22px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: transparent;
  border: none;
  border-radius: var(--radius-sm);
  color: var(--color-text-light);
  cursor: pointer;
  opacity: 0;
  transition: opacity 0.15s, background 0.15s, color 0.15s;
  flex-shrink: 0;
}

.tree-node__header:hover .tree-node__edit-btn {
  opacity: 1;
}

.tree-node__edit-btn:hover {
  background: rgba(32, 201, 151, 0.2);
  color: #20c997;
}

/* User story specific styling */
.tree-node__header:has(.tree-node__icon--userstory) {
  border-left: 2px solid transparent;
  transition: border-color 0.15s;
}

.tree-node__header:has(.tree-node__icon--userstory):hover {
  border-left-color: #20c997;
}
</style>

